正确安全
    代码能干活，少出错
        1. 类型安全
            对类型的可以做的事情进行约束
                内存安全
                    内存访问不出错
                        出错的情况，访问未定义内存，按照时间顺序排列
                            引用空指针
                            使用未初始化指针
                            缓冲区溢出
                                内存越界
                            指针释放后再使用
                            重复释放指针
                        解决措施
                            所有权系统
                                每个被分配的内存都有一个独占其所有权的指针，指针销毁才能释放内存
                                RAII，资源一旦分配就立即初始化
                            借用和生命周期
                                变量有其生命周期，超过则对应内存自动释放。
                                借用，通过标记来告诉编译器检查防止释放后使用。
                            Haskell借鉴来的
                                没有空指针
                                默认const绑定
                                expression
                                高阶函数
                                    传递给函数的参数可以是一个函数
                                代数数据类型
                                    tuple
                                模式匹配
                                    更爽的switch
                                泛型，generic
                                trait，关联类型
                                本地类型推导
                            内存安全加强
                                Affine type
                                    move语义
                                借用、生命周期
                数据竞争

可维护
    人写的简单易懂，日后容易阅读、修改
        失败、错误、异常
        Safe Unsafe
        functional and OOP

efficiency
    最好同样的编码时间，代码在机器上更高效
        零成本抽象
            在编译期完成转换，而非运行时
        编译
            HIR -> MIR -> LLVM IR
                只修改变化的部分，缩短编译时间
                增加了细粒度的掌控和优化，缩短执行时间
                精确的类型检查
