R(U) 是属性集合U上的关系模式，X，Y是U的子集，
    依赖
        该模式上的任意一个可能的关系r，都不存在两个元组在X值相等而在Y值不相等的情况，则称X->Y, X确定Y，或Y依赖X，即X函数作用结果为Y
        即每条记录实例中，如果同一个X值，那么Y值也必须向等。因为函数依赖是可缓存的。
        非平凡的函数依赖
            Y不是X的子集
                完全函数依赖
                    依赖的是整体，任何一部分都不依赖
                部分函数依赖
                    依赖整体是因为依赖的是某个子集
        平凡的函数依赖
            Y是X的子集，当是子集的时候，没有意义，因为子集必然和父集相同，X既是Y值
        KEY
            所谓的码，就是起决定因子的X。而且是非平凡的完全函数依赖. 当部分函数依赖时，完全函数依赖是其子集，也就是KEY是最小的部分函数依赖即KEY是最小的超码。
        考虑KEY时，就看各个属性是否决定其他属性，可以互相决定的，就都是KEY
    范式
        1NF，不存在笛卡尔积的元素的顺序属性值为一个关系
            最低要求、或者叫最重要、或者叫最核心的
        2NF，3NF，BCNF，4NF，5NF
            在1NF之上扩展的，增加的，功能更强大的
                也就是超集的超集的超集的超集
            低级的可以通过模式分解转换成高级的
        2NF，不存在部分依赖
            在1NF的条件之上，附加一个条件，所有的属性要么是主属性，要么完全依赖主属性
                即如果出现依赖，主属性一定时必须被其他非主属性完全依赖，即不存在部分依赖。
            不满足2NF的问题
                1. 所谓的依赖就是有X才能有Y，而不满足2NF,
                    1. 插入异常
                        因为错误的多余的KEY，导致该插入的时候，没有满足不能插入
                    2. 删除异常
                        因为错误的多余的KEY，导致不想要这个本来可以只删除某个属性的值的情况，变成了必须删除整个记录
                    3. 修改复杂
                        因为依赖关系不明确，冗余的修改
        3NF，不存在非主属性间的依赖，即依赖必须放在KEY和非主之间
            非主属性既不传递依赖于码，也不部分依赖于码
            传递依赖即码A决定属性B并且B不决定A，属性B也决定属性C，而本来A即决定B也决定C。这样会非主属性的变化也会影响另一个非主属性变化，这样非主属性就成了KEY的作用了。
        BCNF，不存在主属性对于码的部分依赖
            扩充的第三范式
            
